<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«”æ„Ÿæ˜Ÿæ˜Ÿå¤§å†’éšª - æ‰‹æŒæ§åˆ¶ç‰ˆ</title>
    <!-- å¼•å…¥ MediaPipe Hands èˆ‡ Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary-color: #00d2ff;
            --accent-color: #ffd700;
            --danger-color: #ff4757;
            --bg-color: #1e272e;
            --ui-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* é˜²æ­¢æ²å‹• */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* éŠæˆ²å®¹å™¨ */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 1280px;
            max-height: 720px;
            background: #000;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border-radius: 8px;
        }

        /* æ”å½±æ©Ÿèˆ‡ç•«å¸ƒ */
        .camera-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é¡åƒç¿»è½‰ï¼Œè®“æ“ä½œæ›´ç›´è¦º */
            opacity: 0.3; /* è®“èƒŒæ™¯æš—ä¸€é»ï¼Œçªå‡ºéŠæˆ²å…ƒç´  */
            z-index: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* UI å±¤ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°æŒ‰éˆ• */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD (åˆ†æ•¸æ¿) */
        #hud {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .score-box span {
            color: var(--accent-color);
        }

        /* è¼‰å…¥èˆ‡é¸å–®è¦†è“‹å±¤ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--ui-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: var(--primary-color);
            text-shadow: 0 0 20px var(--primary-color);
            text-align: center;
        }

        p {
            font-size: 18px;
            color: #ddd;
            margin-bottom: 30px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }

        .btn {
            background: linear-gradient(45deg, var(--primary-color), #007bff);
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 210, 255, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 210, 255, 0.6);
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* ç‹€æ…‹æŒ‡ç¤ºå™¨ */
        #status-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ccc;
        }

        .dot.loading { background-color: #f1c40f; animation: blink 1s infinite; }
        .dot.ready { background-color: #2ecc71; }
        .dot.error { background-color: #e74c3c; }

        @keyframes blink {
            50% { opacity: 0.4; }
        }

        /* æ‰‹å‹¢æ•™å­¸åœ–ç¤º */
        .tutorial-icons {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        .icon-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
            color: #aaa;
        }
        .icon-box {
            width: 60px;
            height: 60px;
            border: 2px solid #555;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
        }
        
        /* ç²’å­ç‰¹æ•ˆç•«å¸ƒ */
        #particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        /* æ‰‹æŒè¦–è¦ºå›é¥‹ */
        .hand-feedback {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid rgba(0, 210, 255, 0.5);
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .hand-feedback.active {
            opacity: 1;
        }

    </style>
</head>
<body>

<div id="game-container">
    <!-- æ”å½±æ©Ÿå½±åƒ -->
    <video class="camera-view" id="input-video" playsinline></video>
    
    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="game-canvas"></canvas>
    
    <!-- ç²’å­ç‰¹æ•ˆç•«å¸ƒ -->
    <canvas id="particles-canvas"></canvas>

    <!-- æ‰‹æŒè¦–è¦ºå›é¥‹ -->
    <div id="hand-feedback" class="hand-feedback"></div>

    <!-- UI ç‹€æ…‹å±¤ -->
    <div id="ui-layer">
        <div id="status-indicator">
            <div class="dot loading" id="status-dot"></div>
            <span id="status-text">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</span>
        </div>

        <div id="hud" class="hidden">
            <div>åˆ†æ•¸: <span id="score-display">0</span></div>
            <div>æœ€é«˜åˆ†: <span id="highscore-display">0</span></div>
        </div>
    </div>

    <!-- é–‹å§‹/è¼‰å…¥ç•«é¢ -->
    <div id="start-screen" class="overlay">
        <h1>é«”æ„Ÿæ˜Ÿæ˜Ÿå¤§å†’éšª</h1>
        <p>
            è«‹å…è¨±ä½¿ç”¨æ”å½±æ©Ÿã€‚éŠæˆ²ä¸­è«‹èˆ‰èµ·ä¸€éš»æ‰‹ï¼Œ<br>
            ä½¿ç”¨ <b>æ‰‹æŒä¸­å¿ƒ</b> æ§åˆ¶è—è‰²å…‰çƒç§»å‹•ã€‚
        </p>
        
        <div class="tutorial-icons">
            <div class="icon-item">
                <div class="icon-box" style="border-color: var(--primary-color);">ğŸ–ï¸</div>
                <span>æ‰‹æŒæ§åˆ¶</span>
            </div>
            <div class="icon-item">
                <div class="icon-box" style="border-color: var(--accent-color);">â­</div>
                <span>æ”¶é›†æ˜Ÿæ˜Ÿ</span>
            </div>
            <div class="icon-item">
                <div class="icon-box" style="border-color: var(--danger-color);">ğŸ”´</div>
                <span>é¿é–‹ç´…çƒ</span>
            </div>
        </div>

        <button id="start-btn" class="btn" disabled>è¼‰å…¥ä¸­...</button>
    </div>

    <!-- éŠæˆ²çµæŸç•«é¢ -->
    <div id="game-over-screen" class="overlay hidden">
        <h1 style="color: var(--danger-color)">éŠæˆ²çµæŸ</h1>
        <p>ä½ çš„å¾—åˆ†: <span id="final-score" style="color: white; font-size: 24px; font-weight: bold;">0</span></p>
        <button id="restart-btn" class="btn">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    // --- éŠæˆ²è¨­å®šèˆ‡è®Šæ•¸ ---
    const videoElement = document.getElementById('input-video');
    const gameCanvas = document.getElementById('game-canvas');
    const particlesCanvas = document.getElementById('particles-canvas');
    const gameCtx = gameCanvas.getContext('2d');
    const particlesCtx = particlesCanvas.getContext('2d');
    const handFeedback = document.getElementById('hand-feedback');
    
    // UI å…ƒç´ 
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const hud = document.getElementById('hud');
    const scoreDisplay = document.getElementById('score-display');
    const highScoreDisplay = document.getElementById('highscore-display');
    const finalScoreDisplay = document.getElementById('final-score');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');

    let isGameRunning = false;
    let score = 0;
    let highScore = localStorage.getItem('handGameHighScore') || 0;
    let lastTime = 0;
    let handDetected = false; // è¿½è¹¤æ‰‹éƒ¨æ˜¯å¦è¢«åµæ¸¬åˆ°

    // ç©å®¶è¨­å®š - æé«˜éˆæ•åº¦
    const player = {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
        radius: 25, // ç¨å¾®åŠ å¤§ä¸€é»ï¼Œå› ç‚ºæ˜¯æ‰‹æŒæ§åˆ¶
        color: '#00d2ff',
        targetX: window.innerWidth / 2, // æ‰‹å‹¢ç›®æ¨™ä½ç½®
        targetY: window.innerHeight / 2,
        speed: 0.35, // å¢åŠ éˆæ•åº¦
        trail: [], // è»Œè·¡æ•ˆæœ
        handSize: 0 // æ‰‹æŒå¤§å°
    };

    // éŠæˆ²ç‰©ä»¶é™£åˆ—
    let stars = [];
    let obstacles = [];
    
    // ç”Ÿæˆè¨ˆæ™‚å™¨
    let starTimer = 0;
    let obstacleTimer = 0;
    
    // é›£åº¦èª¿æ•´
    let obstacleSpeedMultiplier = 1;

    // ç²’å­ç³»çµ±
    let particles = [];
    let backgroundParticles = [];

    // --- MediaPipe åˆå§‹åŒ– ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    // æé«˜éˆæ•åº¦è¨­ç½®
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(onHandsResults);

    // è¨­å®šæ”å½±æ©Ÿ
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });

    // å•Ÿå‹•æ”å½±æ©Ÿ
    camera.start()
        .then(() => {
            console.log("æ”å½±æ©Ÿå·²å•Ÿå‹•");
        })
        .catch(err => {
            console.error("æ”å½±æ©ŸéŒ¯èª¤:", err);
            statusDot.className = 'dot error';
            statusText.innerText = "ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿ";
        });

    // ç•¶æ¨¡å‹æº–å‚™å¥½æ™‚
    let isModelLoaded = false;

    // --- éŠæˆ²é‚è¼¯ ---

    function onHandsResults(results) {
        if (!isModelLoaded) {
            isModelLoaded = true;
            statusDot.className = 'dot ready';
            statusText.innerText = "ç³»çµ±æº–å‚™å°±ç·’";
            startBtn.disabled = false;
            startBtn.innerText = "é–‹å§‹éŠæˆ²";
            
            // å‰µå»ºèƒŒæ™¯å¾®ç²’
            createBackgroundParticles();
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // è¨ˆç®—æ‰‹æŒä¸­å¿ƒé» (ä½¿ç”¨æ‰‹è…•å’Œæ‰‹æŒ‡åº•éƒ¨é»çš„å¹³å‡å€¼)
            const wrist = landmarks[0]; // æ‰‹è…•
            const indexMCP = landmarks[5]; // é£ŸæŒ‡åº•éƒ¨
            const middleMCP = landmarks[9]; // ä¸­æŒ‡åº•éƒ¨
            const ringMCP = landmarks[13]; // ç„¡åæŒ‡åº•éƒ¨
            const pinkyMCP = landmarks[17]; // å°æŒ‡åº•éƒ¨
            
            // è¨ˆç®—æ‰‹æŒä¸­å¿ƒé»
            const palmCenterX = (wrist.x + indexMCP.x + middleMCP.x + ringMCP.x + pinkyMCP.x) / 5;
            const palmCenterY = (wrist.y + indexMCP.y + middleMCP.y + ringMCP.y + pinkyMCP.y) / 5;
            
            // è¨ˆç®—æ‰‹æŒå¤§å° (æ‰‹è…•åˆ°ä¸­æŒ‡åº•éƒ¨çš„è·é›¢)
            const handSize = Math.sqrt(
                Math.pow(wrist.x - middleMCP.x, 2) + 
                Math.pow(wrist.y - middleMCP.y, 2)
            ) * gameCanvas.width;
            
            player.handSize = handSize;
            
            // åŸå§‹å½±åƒ x: 0->1. é¡åƒå¾Œ: 1->0.
            player.targetX = (1 - palmCenterX) * gameCanvas.width;
            player.targetY = palmCenterY * gameCanvas.height;
            
            // æ›´æ–°æ‰‹æŒè¦–è¦ºå›é¥‹
            updateHandFeedback(player.targetX, player.targetY, handSize);
            
            handDetected = true;
            
            // æ·»åŠ è»Œè·¡é»
            player.trail.push({x: player.x, y: player.y});
            if (player.trail.length > 10) {
                player.trail.shift();
            }
        } else {
            handDetected = false;
            handFeedback.classList.remove('active');
        }
    }

    // æ›´æ–°æ‰‹æŒè¦–è¦ºå›é¥‹
    function updateHandFeedback(x, y, size) {
        handFeedback.style.left = (x - 50) + 'px';
        handFeedback.style.top = (y - 50) + 'px';
        
        // æ ¹æ“šæ‰‹æŒå¤§å°èª¿æ•´åé¥‹åœˆå¤§å°
        const feedbackSize = Math.min(150, Math.max(80, size));
        handFeedback.style.width = feedbackSize + 'px';
        handFeedback.style.height = feedbackSize + 'px';
        
        handFeedback.classList.add('active');
    }

    // å¹³æ»‘ç§»å‹• (ä½¿ç”¨æ›´é«˜çš„ä¿‚æ•¸ä»¥æé«˜éˆæ•åº¦)
    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function resizeCanvas() {
        const container = document.getElementById('game-container');
        gameCanvas.width = container.clientWidth;
        gameCanvas.height = container.clientHeight;
        particlesCanvas.width = container.clientWidth;
        particlesCanvas.height = container.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    highScoreDisplay.innerText = highScore;

    // å‰µå»ºèƒŒæ™¯å¾®ç²’
    function createBackgroundParticles() {
        const particleCount = 100;
        for (let i = 0; i < particleCount; i++) {
            backgroundParticles.push({
                x: Math.random() * gameCanvas.width,
                y: Math.random() * gameCanvas.height,
                size: Math.random() * 3 + 1,
                speed: Math.random() * 0.5 + 0.1,
                color: i % 3 === 0 ? 'rgba(0, 210, 255, 0.3)' : 
                       i % 3 === 1 ? 'rgba(255, 215, 0, 0.3)' : 'rgba(255, 255, 255, 0.2)'
            });
        }
    }

    // æ›´æ–°å’Œç¹ªè£½èƒŒæ™¯å¾®ç²’
    function updateBackgroundParticles() {
        particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
        
        for (let i = 0; i < backgroundParticles.length; i++) {
            const p = backgroundParticles[i];
            p.y += p.speed;
            
            // å¦‚æœç²’å­è¶…å‡ºåº•éƒ¨ï¼Œé‡ç½®åˆ°é ‚éƒ¨
            if (p.y > particlesCanvas.height) {
                p.y = 0;
                p.x = Math.random() * particlesCanvas.width;
            }
            
            // ç¹ªè£½å¾®ç²’
            particlesCtx.beginPath();
            particlesCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            particlesCtx.fillStyle = p.color;
            particlesCtx.fill();
        }
    }

    // éŠæˆ²è¿´åœˆ
    function gameLoop(timestamp) {
        if (!isGameRunning) return;

        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        // æ›´æ–°èƒŒæ™¯å¾®ç²’
        updateBackgroundParticles();

        // æ¸…é™¤éŠæˆ²ç•«å¸ƒ
        gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        // å¦‚æœæ‰‹è¢«åµæ¸¬åˆ°ï¼Œæ›´æ–°ç©å®¶ä½ç½®ï¼Œå¦å‰‡ä¿æŒåŸä½
        if (handDetected) {
            // æ›´æ–°ç©å®¶ä½ç½® (æé«˜éˆæ•åº¦ï¼Œä½¿ç”¨æ›´é«˜çš„Lerpä¿‚æ•¸)
            player.x = lerp(player.x, player.targetX, player.speed);
            player.y = lerp(player.y, player.targetY, player.speed);
        }
        
        // å¦‚æœæ²’æœ‰åµæ¸¬åˆ°æ‰‹ï¼Œé¡¯ç¤ºæç¤º
        if (!handDetected && isGameRunning) {
            gameCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            gameCtx.font = '20px Arial';
            gameCtx.textAlign = 'center';
            gameCtx.fillText('è«‹å°‡æ‰‹èˆ‰åˆ°æ”å½±æ©Ÿå‰', gameCanvas.width/2, gameCanvas.height/2);
        }

        // ç¹ªè£½ç©å®¶è»Œè·¡
        for (let i = 0; i < player.trail.length; i++) {
            const point = player.trail[i];
            const alpha = i / player.trail.length * 0.5;
            
            gameCtx.beginPath();
            gameCtx.arc(point.x, point.y, player.radius * (i / player.trail.length), 0, 2 * Math.PI);
            gameCtx.fillStyle = `rgba(0, 210, 255, ${alpha})`;
            gameCtx.fill();
            gameCtx.closePath();
        }

        // ç¹ªè£½ç©å®¶ (æ‰‹æŒçƒ)
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.radius, 0, 2 * Math.PI);
        
        // æ ¹æ“šæ‰‹æŒå¤§å°æ”¹è®Šé¡è‰²æ·±æ·º
        const intensity = Math.min(1, player.handSize / 100);
        const colorIntensity = Math.floor(255 * intensity);
        const playerColor = `rgb(${colorIntensity}, ${210 + Math.floor(45 * intensity)}, 255)`;
        
        gameCtx.fillStyle = playerColor;
        gameCtx.shadowBlur = 25;
        gameCtx.shadowColor = playerColor;
        gameCtx.fill();
        gameCtx.shadowBlur = 0;
        gameCtx.closePath();

        // æ·»åŠ ç©å®¶å…‰æšˆæ•ˆæœ
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.radius + 8, 0, 2 * Math.PI);
        gameCtx.strokeStyle = 'rgba(0, 210, 255, 0.5)';
        gameCtx.lineWidth = 3;
        gameCtx.stroke();
        gameCtx.closePath();

        // è™•ç†æ˜Ÿæ˜Ÿ
        starTimer += deltaTime;
        if (starTimer > 1000) { // æ¯ç§’å˜—è©¦ç”Ÿæˆæ˜Ÿæ˜Ÿ
            spawnStar();
            starTimer = 0;
        }

        for (let i = stars.length - 1; i >= 0; i--) {
            const s = stars[i];
            
            // æ˜Ÿæ˜Ÿè„ˆå‹•æ•ˆæœ
            const pulse = Math.sin(timestamp / 200) * 3;
            
            // ç¹ªè£½æ˜Ÿæ˜Ÿ (é‡‘è‰²åœ“å½¢å¸¶å…‰æšˆ)
            gameCtx.beginPath();
            gameCtx.arc(s.x, s.y, s.radius + pulse, 0, 2 * Math.PI);
            gameCtx.fillStyle = '#ffd700';
            gameCtx.shadowBlur = 15;
            gameCtx.shadowColor = '#ffd700';
            gameCtx.fill();
            gameCtx.shadowBlur = 0;
            gameCtx.strokeStyle = '#fff';
            gameCtx.lineWidth = 2;
            gameCtx.stroke();
            gameCtx.closePath();
            
            // æ˜Ÿæ˜Ÿå…§éƒ¨å…‰é»
            gameCtx.beginPath();
            gameCtx.arc(s.x, s.y, s.radius / 2, 0, 2 * Math.PI);
            gameCtx.fillStyle = '#fff';
            gameCtx.fill();
            gameCtx.closePath();

            // ç¢°æ’æª¢æ¸¬ (ç©å®¶ vs æ˜Ÿæ˜Ÿ)
            const dist = Math.hypot(player.x - s.x, player.y - s.y);
            if (dist < player.radius + s.radius) {
                // æ”¶é›†æˆåŠŸ
                score += 10;
                scoreDisplay.innerText = score; // å³æ™‚æ›´æ–°åˆ†æ•¸é¡¯ç¤º
                createParticles(s.x, s.y, '#ffd700', 15);
                createParticles(s.x, s.y, '#ffffff', 10);
                stars.splice(i, 1);
                
                // é›£åº¦éš¨åˆ†æ•¸æå‡
                if (score % 50 === 0) {
                    obstacleSpeedMultiplier += 0.1;
                }
                
                // æ¯æ¬¡æ”¶é›†æ˜Ÿæ˜Ÿéƒ½æ›´æ–°åˆ†æ•¸é¡¯ç¤º
                updateScoreDisplay();
            }
        }

        // è™•ç†éšœç¤™ç‰©
        obstacleTimer += deltaTime;
        // ç”Ÿæˆé »ç‡éš¨é›£åº¦ç•¥å¾®åŠ å¿«ï¼Œä½†æœ‰ä¸Šé™
        let spawnRate = Math.max(500, 1000 - (score * 2)); 
        if (obstacleTimer > spawnRate) {
            spawnObstacle();
            obstacleTimer = 0;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obs = obstacles[i];
            obs.y += obs.speed * obstacleSpeedMultiplier;
            obs.rotation += 0.05;

            // ç¹ªè£½éšœç¤™ç‰© (ç´…è‰²å¸¶åˆºçƒé«”æ„Ÿ)
            gameCtx.save();
            gameCtx.translate(obs.x, obs.y);
            gameCtx.rotate(obs.rotation);
            gameCtx.beginPath();
            // ç•«ä¸€å€‹ç°¡å–®çš„å¤šé‚Šå½¢æ¨¡æ“¬åˆº
            const spikes = 8;
            const outerRadius = obs.radius;
            const innerRadius = obs.radius / 2;
            for(let j=0; j<spikes*2; j++){
                const r = (j%2 === 0) ? outerRadius : innerRadius;
                const currAngle = (Math.PI / spikes) * j;
                const x = Math.cos(currAngle) * r;
                const y = Math.sin(currAngle) * r;
                if(j===0) gameCtx.moveTo(x, y);
                else gameCtx.lineTo(x, y);
            }
            gameCtx.closePath();
            gameCtx.fillStyle = '#ff4757';
            gameCtx.shadowBlur = 10;
            gameCtx.shadowColor = '#ff4757';
            gameCtx.fill();
            gameCtx.shadowBlur = 0;
            gameCtx.restore();

            // ç§»é™¤è¶…å‡ºç•«é¢çš„éšœç¤™ç‰©
            if (obs.y > gameCanvas.height + obs.radius) {
                obstacles.splice(i, 1);
                continue;
            }

            // ç¢°æ’æª¢æ¸¬ (ç©å®¶ vs éšœç¤™ç‰©)
            // ç‚ºäº†å…¬å¹³ä¸€é»ï¼Œéšœç¤™ç‰©ç¢°æ’åˆ¤å®šç¨å¾®æ¯”è¦–è¦ºå°ä¸€é»
            const dist = Math.hypot(player.x - obs.x, player.y - obs.y);
            if (dist < (player.radius + obs.radius * 0.8)) {
                // ç¢°æ’æ™‚ç”¢ç”Ÿçˆ†ç‚¸ç²’å­æ•ˆæœ
                createParticles(obs.x, obs.y, '#ff4757', 30);
                createParticles(player.x, player.y, '#00d2ff', 20);
                gameOver();
                return;
            }
        }

        // ç²’å­æ•ˆæœæ›´æ–°
        updateAndDrawParticles();

        // æŒçºŒç”¢ç”Ÿç©å®¶ç§»å‹•å¾®ç²’
        if (isGameRunning && handDetected && Math.random() < 0.4) {
            createParticles(player.x, player.y, '#00d2ff', 1);
        }

        requestAnimationFrame(gameLoop);
    }

    // å³æ™‚æ›´æ–°åˆ†æ•¸é¡¯ç¤º
    function updateScoreDisplay() {
        scoreDisplay.innerText = score;
        scoreDisplay.style.transform = 'scale(1.2)';
        setTimeout(() => {
            scoreDisplay.style.transform = 'scale(1)';
        }, 200);
    }

    // --- ç”Ÿæˆå™¨ ---

    function spawnStar() {
        if (stars.length > 3) return; // é™åˆ¶åŒæ™‚å­˜åœ¨çš„æ•¸é‡
        stars.push({
            x: Math.random() * (gameCanvas.width - 40) + 20,
            y: Math.random() * (gameCanvas.height - 40) + 20,
            radius: 15
        });
    }

    function spawnObstacle() {
        const radius = Math.random() * 15 + 15; // 15~30
        obstacles.push({
            x: Math.random() * gameCanvas.width,
            y: -radius,
            radius: radius,
            speed: Math.random() * 3 + 2, // åŸºç¤é€Ÿåº¦
            rotation: 0
        });
    }

    // --- ç²’å­ç³»çµ± (è¦–è¦ºæ•ˆæœ) ---
    function createParticles(x, y, color, count = 8) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 1.0,
                color: color,
                size: Math.random() * 4 + 2
            });
        }
    }

    function updateAndDrawParticles() {
        particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
        
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            
            if (p.life <= 0) {
                particles.splice(i, 1);
            } else {
                particlesCtx.globalAlpha = p.life;
                particlesCtx.fillStyle = p.color;
                particlesCtx.beginPath();
                particlesCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                particlesCtx.fill();
                particlesCtx.globalAlpha = 1.0;
            }
        }
    }

    // --- éŠæˆ²æµç¨‹æ§åˆ¶ ---

    function startGame() {
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        hud.classList.remove('hidden');
        
        isGameRunning = true;
        score = 0;
        obstacleSpeedMultiplier = 1;
        scoreDisplay.innerText = score;
        
        stars = [];
        obstacles = [];
        particles = [];
        player.trail = [];

        // åˆå§‹ç”Ÿæˆä¸€å€‹æ˜Ÿæ˜Ÿ
        spawnStar();

        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        isGameRunning = false;
        finalScoreDisplay.innerText = score;
        
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('handGameHighScore', highScore);
            highScoreDisplay.innerText = highScore;
        }

        gameOverScreen.classList.remove('hidden');
        hud.classList.add('hidden');
    }

    // --- äº‹ä»¶ç›£è½ ---
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);

</script>
</body>
</html>
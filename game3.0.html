<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«”æ„Ÿæ˜Ÿæ˜Ÿå¤§å†’éšª - æ‰‹æŒæ§åˆ¶ç‰ˆ</title>
    <!-- å¼•å…¥ MediaPipe Hands èˆ‡ Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary-color: #00d2ff;
            --accent-color: #ffd700;
            --danger-color: #ff4757;
            --bg-color: #1e272e;
            --ui-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* é˜²æ­¢æ²å‹• */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* éŠæˆ²å®¹å™¨ */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 1280px;
            max-height: 720px;
            background: #000;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border-radius: 8px;
        }

        /* æ”å½±æ©Ÿèˆ‡ç•«å¸ƒ */
        .camera-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é¡åƒç¿»è½‰ï¼Œè®“æ“ä½œæ›´ç›´è¦º */
            opacity: 0.3; /* è®“èƒŒæ™¯æš—ä¸€é»ï¼Œçªå‡ºéŠæˆ²å…ƒç´  */
            z-index: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* UI å±¤ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°æŒ‰éˆ• */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD (åˆ†æ•¸æ¿) */
        #hud {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        .score-box span {
            color: var(--accent-color);
        }

        /* æˆå°±é€šçŸ¥æ¨£å¼ */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: -400px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid gold;
            border-radius: 15px;
            padding: 20px;
            min-width: 300px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 3000;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: auto;
        }
        
        .achievement-notification.show {
            right: 20px;
        }
        
        /* æ€§èƒ½ç›£æ§é¢æ¿ */
        .performance-monitor {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 9999;
            display: none;
            pointer-events: auto;
        }
        
        .performance-monitor.active {
            display: block;
        }
        
        /* ç§»å‹•ç«¯å„ªåŒ– */
        @media (max-width: 768px) {
            #ui-layer {
                padding: 10px;
            }
            
            #hud {
                font-size: 18px;
            }
            
            .overlay h1 {
                font-size: 2rem;
            }
            
            .instructions {
                font-size: 0.9rem;
            }
            
            .performance-monitor {
                font-size: 10px;
                padding: 5px;
            }
        }
        
        /* è¼‰å…¥èˆ‡é¸å–®è¦†è“‹å±¤ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--ui-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: var(--primary-color);
            text-shadow: 0 0 20px var(--primary-color);
            text-align: center;
        }

        p {
            font-size: 18px;
            color: #ddd;
            margin-bottom: 30px;
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }

        .btn {
            background: linear-gradient(45deg, var(--primary-color), #007bff);
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 210, 255, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 210, 255, 0.6);
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* æ§åˆ¶æ¨¡å¼é¸æ“‡å™¨ */
        .control-mode-selector {
            margin: 30px 0;
            text-align: center;
        }

        .control-mode-selector h3 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .control-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            margin: 0 auto;
        }

        .control-option {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-option input[type="radio"] {
            display: none;
        }

        .option-content {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .control-option input[type="radio"]:checked + .option-content {
            background: rgba(0, 210, 255, 0.1);
            border-color: var(--primary-color);
            box-shadow: 0 4px 15px rgba(0, 210, 255, 0.2);
        }

        .control-option:hover .option-content {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(5px);
        }

        .option-icon {
            font-size: 2rem;
            width: 50px;
            text-align: center;
        }

        .option-text {
            text-align: left;
            flex: 1;
        }

        .option-title {
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .option-desc {
            font-size: 0.9rem;
            opacity: 0.8;
            line-height: 1.3;
        }

        /* ç‹€æ…‹æŒ‡ç¤ºå™¨ */
        #status-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ccc;
        }

        .dot.loading { background-color: #f1c40f; animation: blink 1s infinite; }
        .dot.ready { background-color: #2ecc71; }
        .dot.error { background-color: #e74c3c; }

        @keyframes blink {
            50% { opacity: 0.4; }
        }

        /* æ‰‹å‹¢æ•™å­¸åœ–ç¤º */
        .tutorial-icons {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        .icon-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
            color: #aaa;
        }
        .icon-box {
            width: 60px;
            height: 60px;
            border: 2px solid #555;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
        }
        
        /* ç²’å­ç‰¹æ•ˆç•«å¸ƒ */
        #particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        /* æ‰‹æŒè¦–è¦ºå›é¥‹ */
        .hand-feedback {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid rgba(0, 210, 255, 0.5);
            z-index: 5;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .hand-feedback.active {
            opacity: 1;
        }

    </style>
</head>
<body>

<div id="game-container">
    <!-- æ”å½±æ©Ÿå½±åƒ -->
    <video class="camera-view" id="input-video" playsinline></video>
    
    <!-- éŠæˆ²ç•«å¸ƒ -->
    <canvas id="game-canvas"></canvas>
    
    <!-- ç²’å­ç‰¹æ•ˆç•«å¸ƒ -->
    <canvas id="particles-canvas"></canvas>

    <!-- æ‰‹æŒè¦–è¦ºå›é¥‹ -->
    <div id="hand-feedback" class="hand-feedback"></div>

    <!-- UI ç‹€æ…‹å±¤ -->
    <div id="ui-layer">
        <div id="status-indicator">
            <div class="dot loading" id="status-dot"></div>
            <span id="status-text">æ­£åœ¨è¼‰å…¥ AI æ¨¡å‹...</span>
        </div>

        <div id="hud" class="hidden">
            <div>åˆ†æ•¸: <span id="score-display">0</span></div>
            <div>æœ€é«˜åˆ†: <span id="highscore-display">0</span></div>
        </div>
    </div>

    <!-- é–‹å§‹/è¼‰å…¥ç•«é¢ -->
    <div id="start-screen" class="overlay">
        <h1>é«”æ„Ÿæ˜Ÿæ˜Ÿå¤§å†’éšª</h1>
        <p>
            è«‹å…è¨±ä½¿ç”¨æ”å½±æ©Ÿã€‚éŠæˆ²ä¸­è«‹èˆ‰èµ·ä¸€éš»æ‰‹ï¼Œ<br>
            ä½¿ç”¨ <b>æ‰‹æŒä¸­å¿ƒ</b> æ§åˆ¶è—è‰²å…‰çƒç§»å‹•ã€‚
        </p>
        
        <div class="control-mode-selector">
            <h3>é¸æ“‡æ§åˆ¶æ¨¡å¼</h3>
            <div class="control-options">
                <label class="control-option">
                    <input type="radio" name="control-mode" value="hand" checked>
                    <div class="option-content">
                        <div class="option-icon">ğŸ–ï¸</div>
                        <div class="option-text">
                            <div class="option-title">æ‰‹æŒæ§åˆ¶</div>
                            <div class="option-desc">ä½¿ç”¨æ”å½±æ©Ÿå’ŒAIè­˜åˆ¥æ‰‹å‹¢</div>
                        </div>
                    </div>
                </label>
                <label class="control-option">
                    <input type="radio" name="control-mode" value="touch">
                    <div class="option-content">
                        <div class="option-icon">ğŸ‘†</div>
                        <div class="option-text">
                            <div class="option-title">è§¸æ§/æ»‘é¼ </div>
                            <div class="option-desc">é»æ“Šæˆ–æ‹–å‹•æ§åˆ¶ç§»å‹•</div>
                        </div>
                    </div>
                </label>
                <label class="control-option">
                    <input type="radio" name="control-mode" value="keyboard">
                    <div class="option-content">
                        <div class="option-icon">âŒ¨ï¸</div>
                        <div class="option-text">
                            <div class="option-title">éµç›¤æ§åˆ¶</div>
                            <div class="option-desc">ä½¿ç”¨æ–¹å‘éµæˆ–WASDç§»å‹•</div>
                        </div>
                    </div>
                </label>
            </div>
        </div>

        <div class="tutorial-icons">
            <div class="icon-item">
                <div class="icon-box" style="border-color: var(--primary-color);">ğŸ–ï¸</div>
                <span>æ‰‹æŒæ§åˆ¶</span>
            </div>
            <div class="icon-item">
                <div class="icon-box" style="border-color: var(--accent-color);">â­</div>
                <span>æ”¶é›†æ˜Ÿæ˜Ÿ</span>
            </div>
            <div class="icon-item">
                <div class="icon-box" style="border-color: var(--danger-color);">ğŸ”´</div>
                <span>é¿é–‹ç´…çƒ</span>
            </div>
        </div>

        <button id="start-btn" class="btn" disabled>è¼‰å…¥ä¸­...</button>
    </div>

    <!-- éŠæˆ²çµæŸç•«é¢ -->
    <div id="game-over-screen" class="overlay hidden">
        <h1 style="color: var(--danger-color)">éŠæˆ²çµæŸ</h1>
        <p>ä½ çš„å¾—åˆ†: <span id="final-score" style="color: white; font-size: 24px; font-weight: bold;">0</span></p>
        <button id="restart-btn" class="btn">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script>
    // ç­‰å¾…DOMå®Œå…¨åŠ è¼‰
    document.addEventListener('DOMContentLoaded', function() {
        // --- éŠæˆ²è¨­å®šèˆ‡è®Šæ•¸ ---
        const videoElement = document.getElementById('input-video');
    const gameCanvas = document.getElementById('game-canvas');
    const particlesCanvas = document.getElementById('particles-canvas');
    const gameCtx = gameCanvas.getContext('2d');
    const particlesCtx = particlesCanvas.getContext('2d');
    const handFeedback = document.getElementById('hand-feedback');
    
    // UI å…ƒç´ 
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const hud = document.getElementById('hud');
    const scoreDisplay = document.getElementById('score-display');
    const highScoreDisplay = document.getElementById('highscore-display');
    const finalScoreDisplay = document.getElementById('final-score');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');

    let isGameRunning = false;
    let score = 0;
    let highScore = localStorage.getItem('handGameHighScore') || 0;
    let lastTime = 0;
    let handDetected = false; // è¿½è¹¤æ‰‹éƒ¨æ˜¯å¦è¢«åµæ¸¬åˆ°

    // ç©å®¶è¨­å®š - æé«˜éˆæ•åº¦
    const player = {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
        radius: 25, // ç¨å¾®åŠ å¤§ä¸€é»ï¼Œå› ç‚ºæ˜¯æ‰‹æŒæ§åˆ¶
        color: '#00d2ff',
        targetX: window.innerWidth / 2, // æ‰‹å‹¢ç›®æ¨™ä½ç½®
        targetY: window.innerHeight / 2,
        speed: 0.35, // å¢åŠ éˆæ•åº¦
        trail: [], // è»Œè·¡æ•ˆæœ
        handSize: 0 // æ‰‹æŒå¤§å°
    };

    // éŠæˆ²ç‰©ä»¶é™£åˆ—
    let stars = [];
    let obstacles = [];
    
    // ç”Ÿæˆè¨ˆæ™‚å™¨
    let starTimer = 0;
    let obstacleTimer = 0;
    
    // é›£åº¦èª¿æ•´
    let obstacleSpeedMultiplier = 1;

    // ç²’å­ç³»çµ±
    let particles = [];
    let backgroundParticles = [];

    // --- MediaPipe åˆå§‹åŒ– ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    // æé«˜éˆæ•åº¦è¨­ç½®
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(onHandsResults);

    // è¨­å®šæ”å½±æ©Ÿ
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });

    // å•Ÿå‹•æ”å½±æ©Ÿ
    camera.start()
        .then(() => {
            console.log("æ”å½±æ©Ÿå·²å•Ÿå‹•");
        })
        .catch(err => {
            console.error("æ”å½±æ©ŸéŒ¯èª¤:", err);
            statusDot.className = 'dot error';
            statusText.innerText = "ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿ";
        });

    // ç•¶æ¨¡å‹æº–å‚™å¥½æ™‚
    let isModelLoaded = false;

    // --- éŸ³æ•ˆç³»çµ± ---
    class GameAudio {
        constructor() {
            this.audioContext = null;
            this.initialized = false;
            this.masterVolume = 0.4;
            this.enabled = true;
            this.backgroundMusicEnabled = true;
        }
        
        init() {
            if (this.initialized) return;
            
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.initialized = true;
                this.masterGainNode = this.audioContext.createGain();
                this.masterGainNode.connect(this.audioContext.destination);
                this.masterGainNode.gain.value = this.masterVolume;
            } catch (error) {
                console.warn('éŸ³æ•ˆç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
                this.enabled = false;
            }
        }
        
        playSound(frequency, duration, type = 'sine', volume = 0.5, modulation = null) {
            if (!this.enabled || !this.initialized) return;
            
            try {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGainNode);
                
                oscillator.type = type;
                oscillator.frequency.value = frequency;
                
                // æ·»åŠ éŸ³é »èª¿è£½ï¼ˆå¦‚æœæä¾›ï¼‰
                if (modulation) {
                    const lfo = this.audioContext.createOscillator();
                    const lfoGain = this.audioContext.createGain();
                    lfo.frequency.value = modulation.frequency;
                    lfoGain.gain.value = modulation.amount;
                    lfo.connect(lfoGain);
                    lfoGain.connect(oscillator.frequency);
                    lfo.start();
                }
                
                gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
                
            } catch (error) {
                console.warn('æ’­æ”¾éŸ³æ•ˆå¤±æ•—:', error);
            }
        }
        
        playCollect() {
            // æ˜Ÿæ˜Ÿæ”¶é›†éŸ³æ•ˆ - ä¸Šå‡çš„éŸ³éš
            const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    this.playSound(freq, 0.2, 'triangle', 0.6);
                    // æ·»åŠ å’Œè²
                    this.playSound(freq * 1.5, 0.15, 'sine', 0.3);
                }, index * 50);
            });
            
            // è§¸è¦ºåé¥‹
            if ('vibrate' in navigator) {
                navigator.vibrate([20, 10, 30]);
            }
        }
        
        playCollision() {
            // ç¢°æ’éŸ³æ•ˆ - å™ªéŸ³å’Œä½é »
            const noise = this.createNoise(0.3);
            const filter = this.audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 200;
            filter.Q.value = 5;
            
            noise.connect(filter);
            filter.connect(this.masterGainNode);
            
            const gainNode = this.audioContext.createGain();
            gainNode.gain.setValueAtTime(0.8, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
            
            filter.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            noise.start();
            noise.stop(this.audioContext.currentTime + 0.3);
            
            // ä½é »è¡æ“ŠéŸ³
            this.playSound(80, 0.4, 'sawtooth', 0.7);
            
            // å¼·çƒˆéœ‡å‹•
            if ('vibrate' in navigator) {
                navigator.vibrate([100, 50, 150]);
            }
        }
        
        playHandDetected() {
            // æ‰‹å‹¢æª¢æ¸¬éŸ³æ•ˆ - è¼•æŸ”çš„æç¤ºéŸ³
            this.playSound(440, 0.1, 'sine', 0.3);
            setTimeout(() => this.playSound(554.37, 0.1, 'sine', 0.2), 50);
        }
        
        playStartGame() {
            // éŠæˆ²é–‹å§‹éŸ³æ•ˆ - æ¿€å‹µçš„ä¸Šå‡éŸ³
            const sequence = [
                {freq: 261.63, duration: 0.15}, // C4
                {freq: 329.63, duration: 0.15}, // E4
                {freq: 392.00, duration: 0.15}, // G4
                {freq: 523.25, duration: 0.25}, // C5
            ];
            
            sequence.forEach((note, index) => {
                setTimeout(() => {
                    this.playSound(note.freq, note.duration, 'triangle', 0.5);
                    this.playSound(note.freq * 2, note.duration * 0.5, 'sine', 0.3);
                }, index * 100);
            });
            
            // é–‹å§‹éœ‡å‹•
            if ('vibrate' in navigator) {
                navigator.vibrate([30, 20, 40, 20, 50]);
            }
        }
        
        playGameOver() {
            // éŠæˆ²çµæŸéŸ³æ•ˆ - ä¸‹é™çš„éŸ³éš
            const freq = [523.25, 415.30, 329.63, 261.63, 196.00];
            freq.forEach((f, i) => {
                setTimeout(() => {
                    this.playSound(f, 0.3, 'sawtooth', 0.4);
                    this.playSound(f * 0.5, 0.3, 'sine', 0.2);
                }, i * 150);
            });
            
            // çµæŸéœ‡å‹•
            if ('vibrate' in navigator) {
                navigator.vibrate([200, 100, 200]);
            }
        }
        
        playBackgroundAmbient() {
            if (!this.backgroundMusicEnabled) return;
            
            // å‰µå»ºç’°å¢ƒèƒŒæ™¯éŸ³
            const oscillator1 = this.audioContext.createOscillator();
            const oscillator2 = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator1.type = 'sine';
            oscillator2.type = 'triangle';
            oscillator1.frequency.value = 110; // A2
            oscillator2.frequency.value = 165; // E3
            
            // æ·»åŠ è¼•å¾®çš„LFOèª¿è£½
            const lfo = this.audioContext.createOscillator();
            const lfoGain = this.audioContext.createGain();
            lfo.frequency.value = 0.2;
            lfoGain.gain.value = 5;
            lfo.connect(lfoGain);
            lfoGain.connect(oscillator1.frequency);
            lfoGain.connect(oscillator2.frequency);
            
            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(this.masterGainNode);
            
            gainNode.gain.value = 0.05; // å¾ˆä½çš„éŸ³é‡
            
            oscillator1.start();
            oscillator2.start();
            lfo.start();
            
            // ä¿å­˜å¼•ç”¨ä»¥ä¾¿åœæ­¢
            this.backgroundOscillators = [oscillator1, oscillator2, lfo];
            this.backgroundGainNode = gainNode;
        }
        
        stopBackgroundAmbient() {
            if (this.backgroundOscillators) {
                this.backgroundOscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch (e) {}
                });
                this.backgroundOscillators = null;
            }
        }
        
        createNoise(duration) {
            const bufferSize = this.audioContext.sampleRate * duration;
            const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
            const output = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = this.audioContext.createBufferSource();
            noise.buffer = buffer;
            return noise;
        }
        
        setVolume(volume) {
            this.masterVolume = Math.max(0, Math.min(1, volume));
            if (this.masterGainNode) {
                this.masterGainNode.gain.value = this.masterVolume;
            }
        }
        
        toggle(enabled) {
            this.enabled = enabled;
        }
        
        toggleBackgroundMusic(enabled) {
            this.backgroundMusicEnabled = enabled;
            if (!enabled) {
                this.stopBackgroundAmbient();
            }
        }
    }
    
    // åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
    const gameAudio = new GameAudio();

    // --- å‚™ç”¨æ§åˆ¶ç³»çµ± ---
    class FallbackControls {
        constructor() {
            this.mode = 'hand'; // 'hand', 'touch', 'keyboard'
            this.isEnabled = false;
            this.targetX = 0;
            this.targetY = 0;
            this.smoothingFactor = 0.15;
            this.keyboardSpeed = 5;
            this.keysPressed = {};
            
            this.init();
        }
        
        init() {
            this.setupEventListeners();
        }
        
        setupEventListeners() {
            // æ§åˆ¶æ¨¡å¼é¸æ“‡
            const modeRadios = document.querySelectorAll('input[name="control-mode"]');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    this.setMode(e.target.value);
                });
            });
            
            // éµç›¤æ§åˆ¶
            document.addEventListener('keydown', (e) => {
                if (this.mode !== 'keyboard' || !this.isEnabled) return;
                this.keysPressed[e.key.toLowerCase()] = true;
                e.preventDefault();
            });
            
            document.addEventListener('keyup', (e) => {
                this.keysPressed[e.key.toLowerCase()] = false;
                e.preventDefault();
            });
            
            // è§¸æ‘¸/æ»‘é¼ æ§åˆ¶
            const gameCanvas = document.getElementById('game-canvas');
            
            gameCanvas.addEventListener('mousedown', (e) => {
                if (this.mode !== 'touch' || !this.isEnabled) return;
                this.handlePointerMove(e.clientX, e.clientY);
            });
            
            gameCanvas.addEventListener('mousemove', (e) => {
                if (this.mode !== 'touch' || !this.isEnabled) return;
                if (e.buttons === 1) { // åªæœ‰åœ¨æŒ‰ä½æ»‘é¼ æ™‚
                    this.handlePointerMove(e.clientX, e.clientY);
                }
            });
            
            gameCanvas.addEventListener('touchstart', (e) => {
                if (this.mode !== 'touch' || !this.isEnabled) return;
                e.preventDefault();
                const touch = e.touches[0];
                this.handlePointerMove(touch.clientX, touch.clientY);
            });
            
            gameCanvas.addEventListener('touchmove', (e) => {
                if (this.mode !== 'touch' || !this.isEnabled) return;
                e.preventDefault();
                const touch = e.touches[0];
                this.handlePointerMove(touch.clientX, touch.clientY);
            });
        }
        
        setMode(mode) {
            this.mode = mode;
            console.log(`æ§åˆ¶æ¨¡å¼åˆ‡æ›åˆ°: ${mode}`);
            
            // æ ¹æ“šæ¨¡å¼èª¿æ•´UI
            if (mode === 'hand') {
                // é¡¯ç¤ºæ”å½±æ©Ÿå’Œæ‰‹å‹¢åé¥‹
                document.getElementById('input-video').style.display = 'block';
                document.getElementById('hand-feedback').style.display = 'block';
            } else {
                // éš±è—æ”å½±æ©Ÿç›¸é—œå…ƒç´ 
                document.getElementById('input-video').style.display = 'none';
                document.getElementById('hand-feedback').style.display = 'none';
                
                // é¡¯ç¤ºæ§åˆ¶æç¤º
                this.showControlHint(mode);
            }
        }
        
        showControlHint(mode) {
            const hints = {
                'touch': 'é»æ“Šä¸¦æ‹–å‹•ä¾†æ§åˆ¶å…‰çƒç§»å‹•',
                'keyboard': 'ä½¿ç”¨æ–¹å‘éµæˆ–WASDæ§åˆ¶ç§»å‹•'
            };
            
            // å‰µå»ºæç¤ºå…ƒç´ 
            const hint = document.createElement('div');
            hint.className = 'control-hint';
            hint.textContent = hints[mode] || '';
            hint.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 12px 20px;
                border-radius: 20px;
                font-size: 14px;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            
            document.body.appendChild(hint);
            
            // é¡¯ç¤ºæç¤º
            setTimeout(() => {
                hint.style.opacity = '1';
            }, 100);
            
            // 3ç§’å¾Œç§»é™¤æç¤º
            setTimeout(() => {
                hint.style.opacity = '0';
                setTimeout(() => {
                    if (hint.parentNode) {
                        hint.parentNode.removeChild(hint);
                    }
                }, 300);
            }, 3000);
        }
        
        handlePointerMove(clientX, clientY) {
            const canvas = document.getElementById('game-canvas');
            const rect = canvas.getBoundingClientRect();
            
            // å°‡å±å¹•åæ¨™è½‰æ›ç‚ºéŠæˆ²åæ¨™
            this.targetX = (clientX - rect.left) * (canvas.width / rect.width);
            this.targetY = (clientY - rect.top) * (canvas.height / rect.height);
        }
        
        updatePlayerPosition(player) {
            if (!this.isEnabled) return;
            
            if (this.mode === 'touch') {
                // å¹³æ»‘ç§»å‹•åˆ°ç›®æ¨™ä½ç½®
                const dx = this.targetX - player.x;
                const dy = this.targetY - player.y;
                player.x += dx * this.smoothingFactor;
                player.y += dy * this.smoothingFactor;
                
            } else if (this.mode === 'keyboard') {
                // éµç›¤æ§åˆ¶
                if (this.keysPressed['arrowup'] || this.keysPressed['w']) {
                    player.y = Math.max(player.radius, player.y - this.keyboardSpeed);
                }
                if (this.keysPressed['arrowdown'] || this.keysPressed['s']) {
                    player.y = Math.min(gameCanvas.height - player.radius, player.y + this.keyboardSpeed);
                }
                if (this.keysPressed['arrowleft'] || this.keysPressed['a']) {
                    player.x = Math.max(player.radius, player.x - this.keyboardSpeed);
                }
                if (this.keysPressed['arrowright'] || this.keysPressed['d']) {
                    player.x = Math.min(gameCanvas.width - player.radius, player.x + this.keyboardSpeed);
                }
            }
        }
        
        enable() {
            this.isEnabled = true;
            // ç‚ºéæ‰‹æŒæ¨¡å¼è¨­ç½®åˆå§‹ä½ç½®
            if (this.mode !== 'hand') {
                const canvas = document.getElementById('game-canvas');
                this.targetX = canvas.width / 2;
                this.targetY = canvas.height / 2;
            }
        }
        
        disable() {
            this.isEnabled = false;
            this.keysPressed = {};
        }
    }
    
    // åˆå§‹åŒ–å‚™ç”¨æ§åˆ¶ç³»çµ±
    const fallbackControls = new FallbackControls();

    // --- æ€§èƒ½å„ªåŒ–ç³»çµ± ---
    class PerformanceOptimizer {
        constructor() {
            this.targetFPS = 60;
            this.currentFPS = 60;
            this.fpsHistory = [];
            this.maxHistoryLength = 60;
            this.qualityLevel = 'high';
            this.lastFrameTime = performance.now();
            this.frameCount = 0;
            this.adaptiveQuality = true;
            
            this.init();
        }
        
        init() {
            this.detectDevicePerformance();
            this.startFPSMonitoring();
        }
        
        detectDevicePerformance() {
            const hardwareConcurrency = navigator.hardwareConcurrency || 2;
            const deviceMemory = navigator.deviceMemory || 4;
            
            if (hardwareConcurrency < 4 || deviceMemory < 4) {
                this.qualityLevel = 'medium';
            }
            
            if (hardwareConcurrency < 2 || deviceMemory < 2) {
                this.qualityLevel = 'low';
            }
            
            console.log(`è¨­å‚™æ€§èƒ½æª¢æ¸¬: CPUæ ¸å¿ƒ=${hardwareConcurrency}, å…§å­˜=${deviceMemory}GB`);
            console.log(`åˆå§‹è³ªé‡ç´šåˆ¥: ${this.qualityLevel}`);
        }
        
        startFPSMonitoring() {
            const monitor = () => {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastFrameTime;
                const currentFPS = 1000 / deltaTime;
                
                this.fpsHistory.push(currentFPS);
                if (this.fpsHistory.length > this.maxHistoryLength) {
                    this.fpsHistory.shift();
                }
                
                this.currentFPS = this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;
                this.lastFrameTime = currentTime;
                this.frameCount++;
                
                if (this.frameCount % 60 === 0 && this.adaptiveQuality) {
                    this.adjustQuality();
                }
                
                requestAnimationFrame(monitor);
            };
            
            requestAnimationFrame(monitor);
        }
        
        adjustQuality() {
            const avgFPS = this.currentFPS;
            
            if (avgFPS < 45 && this.qualityLevel !== 'low') {
                this.qualityLevel = this.qualityLevel === 'high' ? 'medium' : 'low';
                console.log(`æ€§èƒ½ä¸è¶³ï¼Œé™ä½è³ªé‡åˆ°: ${this.qualityLevel}`);
            } else if (avgFPS > 55 && this.qualityLevel !== 'high') {
                this.qualityLevel = this.qualityLevel === 'low' ? 'medium' : 'high';
                console.log(`æ€§èƒ½è‰¯å¥½ï¼Œæå‡è³ªé‡åˆ°: ${this.qualityLevel}`);
            }
        }
        
        getMaxParticles() {
            const maxParticles = {
                high: 100,
                medium: 50,
                low: 25
            };
            return maxParticles[this.qualityLevel] || 50;
        }
        
        shouldSkipFrame() {
            return this.qualityLevel === 'low' && this.currentFPS < 30;
        }
        
        getOptimalParticleCount() {
            return this.getMaxParticles();
        }
        
        getCurrentFPS() {
            return Math.round(this.currentFPS);
        }
        
        getQualityLevel() {
            return this.qualityLevel;
        }
    }
    
    // åˆå§‹åŒ–æ€§èƒ½å„ªåŒ–å™¨
    const performanceOptimizer = new PerformanceOptimizer();

    // --- éŠæˆ²é‚è¼¯ ---

    function onHandsResults(results) {
        if (!isModelLoaded) {
            isModelLoaded = true;
            statusDot.className = 'dot ready';
            statusText.innerText = "ç³»çµ±æº–å‚™å°±ç·’";
            startBtn.disabled = false;
            startBtn.innerText = "é–‹å§‹éŠæˆ²";
            
            // å‰µå»ºèƒŒæ™¯å¾®ç²’
            createBackgroundParticles();
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // æ‰‹å‹¢æª¢æ¸¬åé¥‹ï¼ˆä½é »ç‡ï¼Œé¿å…ç…©äººï¼‰
            if (Math.random() < 0.02) { // 2%æ©Ÿç‡æ’­æ”¾æç¤ºéŸ³
                gameAudio.playHandDetected();
            }
            
            // è¨ˆç®—æ‰‹æŒä¸­å¿ƒé» (ä½¿ç”¨æ‰‹è…•å’Œæ‰‹æŒ‡åº•éƒ¨é»çš„å¹³å‡å€¼)
            const wrist = landmarks[0]; // æ‰‹è…•
            const indexMCP = landmarks[5]; // é£ŸæŒ‡åº•éƒ¨
            const middleMCP = landmarks[9]; // ä¸­æŒ‡åº•éƒ¨
            const ringMCP = landmarks[13]; // ç„¡åæŒ‡åº•éƒ¨
            const pinkyMCP = landmarks[17]; // å°æŒ‡åº•éƒ¨
            
            // è¨ˆç®—æ‰‹æŒä¸­å¿ƒé»
            const palmCenterX = (wrist.x + indexMCP.x + middleMCP.x + ringMCP.x + pinkyMCP.x) / 5;
            const palmCenterY = (wrist.y + indexMCP.y + middleMCP.y + ringMCP.y + pinkyMCP.y) / 5;
            
            // è¨ˆç®—æ‰‹æŒå¤§å° (æ‰‹è…•åˆ°ä¸­æŒ‡åº•éƒ¨çš„è·é›¢)
            const handSize = Math.sqrt(
                Math.pow(wrist.x - middleMCP.x, 2) + 
                Math.pow(wrist.y - middleMCP.y, 2)
            ) * gameCanvas.width;
            
            player.handSize = handSize;
            
            // åŸå§‹å½±åƒ x: 0->1. é¡åƒå¾Œ: 1->0.
            player.targetX = (1 - palmCenterX) * gameCanvas.width;
            player.targetY = palmCenterY * gameCanvas.height;
            
            // æ›´æ–°æ‰‹æŒè¦–è¦ºå›é¥‹
            updateHandFeedback(player.targetX, player.targetY, handSize);
            
            handDetected = true;
            
            // æ·»åŠ è»Œè·¡é»
            player.trail.push({x: player.x, y: player.y});
            if (player.trail.length > 10) {
                player.trail.shift();
            }
        } else {
            handDetected = false;
            handFeedback.classList.remove('active');
        }
    }

    // æ›´æ–°æ‰‹æŒè¦–è¦ºå›é¥‹
    function updateHandFeedback(x, y, size) {
        handFeedback.style.left = (x - 50) + 'px';
        handFeedback.style.top = (y - 50) + 'px';
        
        // æ ¹æ“šæ‰‹æŒå¤§å°èª¿æ•´åé¥‹åœˆå¤§å°
        const feedbackSize = Math.min(150, Math.max(80, size));
        handFeedback.style.width = feedbackSize + 'px';
        handFeedback.style.height = feedbackSize + 'px';
        
        handFeedback.classList.add('active');
    }

    // å¹³æ»‘ç§»å‹• (ä½¿ç”¨æ›´é«˜çš„ä¿‚æ•¸ä»¥æé«˜éˆæ•åº¦)
    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function resizeCanvas() {
        const container = document.getElementById('game-container');
        gameCanvas.width = container.clientWidth;
        gameCanvas.height = container.clientHeight;
        particlesCanvas.width = container.clientWidth;
        particlesCanvas.height = container.clientHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    highScoreDisplay.innerText = highScore;

    // å‰µå»ºèƒŒæ™¯å¾®ç²’
    function createBackgroundParticles() {
        const particleCount = 100;
        for (let i = 0; i < particleCount; i++) {
            backgroundParticles.push({
                x: Math.random() * gameCanvas.width,
                y: Math.random() * gameCanvas.height,
                size: Math.random() * 3 + 1,
                speed: Math.random() * 0.5 + 0.1,
                color: i % 3 === 0 ? 'rgba(0, 210, 255, 0.3)' : 
                       i % 3 === 1 ? 'rgba(255, 215, 0, 0.3)' : 'rgba(255, 255, 255, 0.2)'
            });
        }
    }

    // æ›´æ–°å’Œç¹ªè£½èƒŒæ™¯å¾®ç²’
    function updateBackgroundParticles() {
        particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
        
        for (let i = 0; i < backgroundParticles.length; i++) {
            const p = backgroundParticles[i];
            p.y += p.speed;
            
            // å¦‚æœç²’å­è¶…å‡ºåº•éƒ¨ï¼Œé‡ç½®åˆ°é ‚éƒ¨
            if (p.y > particlesCanvas.height) {
                p.y = 0;
                p.x = Math.random() * particlesCanvas.width;
            }
            
            // ç¹ªè£½å¾®ç²’
            particlesCtx.beginPath();
            particlesCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            particlesCtx.fillStyle = p.color;
            particlesCtx.fill();
        }
    }

    // éŠæˆ²è¿´åœˆ
    function gameLoop(timestamp) {
        if (!isGameRunning) return;

        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        // æ›´æ–°èƒŒæ™¯å¾®ç²’
        updateBackgroundParticles();

        // æ¸…é™¤éŠæˆ²ç•«å¸ƒ
        gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        // å¦‚æœæ‰‹è¢«åµæ¸¬åˆ°ï¼Œæ›´æ–°ç©å®¶ä½ç½®ï¼Œå¦å‰‡ä¿æŒåŸä½
        if (fallbackControls.mode === 'hand') {
            if (handDetected) {
                // æ›´æ–°ç©å®¶ä½ç½® (æé«˜éˆæ•åº¦ï¼Œä½¿ç”¨æ›´é«˜çš„Lerpä¿‚æ•¸)
                player.x = lerp(player.x, player.targetX, player.speed);
                player.y = lerp(player.y, player.targetY, player.speed);
            }
            
            // å¦‚æœæ²’æœ‰åµæ¸¬åˆ°æ‰‹ï¼Œé¡¯ç¤ºæç¤º
            if (!handDetected && isGameRunning) {
                gameCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                gameCtx.font = '20px Arial';
                gameCtx.textAlign = 'center';
                gameCtx.fillText('è«‹å°‡æ‰‹èˆ‰åˆ°æ”å½±æ©Ÿå‰', gameCanvas.width/2, gameCanvas.height/2);
            }
        } else {
            // ä½¿ç”¨å‚™ç”¨æ§åˆ¶ç³»çµ±
            fallbackControls.updatePlayerPosition(player);
            
            // éš±è—æ”å½±æ©Ÿç›¸é—œçš„UI
            document.getElementById('status-indicator').style.display = 'none';
        }

        // ç¹ªè£½ç©å®¶è»Œè·¡
        for (let i = 0; i < player.trail.length; i++) {
            const point = player.trail[i];
            const alpha = i / player.trail.length * 0.5;
            
            gameCtx.beginPath();
            gameCtx.arc(point.x, point.y, player.radius * (i / player.trail.length), 0, 2 * Math.PI);
            gameCtx.fillStyle = `rgba(0, 210, 255, ${alpha})`;
            gameCtx.fill();
            gameCtx.closePath();
        }

        // ç¹ªè£½ç©å®¶ (æ‰‹æŒçƒ)
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.radius, 0, 2 * Math.PI);
        
        // æ ¹æ“šæ‰‹æŒå¤§å°æ”¹è®Šé¡è‰²æ·±æ·º
        const intensity = Math.min(1, player.handSize / 100);
        const colorIntensity = Math.floor(255 * intensity);
        const playerColor = `rgb(${colorIntensity}, ${210 + Math.floor(45 * intensity)}, 255)`;
        
        gameCtx.fillStyle = playerColor;
        gameCtx.shadowBlur = 25;
        gameCtx.shadowColor = playerColor;
        gameCtx.fill();
        gameCtx.shadowBlur = 0;
        gameCtx.closePath();

        // æ·»åŠ ç©å®¶å…‰æšˆæ•ˆæœ
        gameCtx.beginPath();
        gameCtx.arc(player.x, player.y, player.radius + 8, 0, 2 * Math.PI);
        gameCtx.strokeStyle = 'rgba(0, 210, 255, 0.5)';
        gameCtx.lineWidth = 3;
        gameCtx.stroke();
        gameCtx.closePath();

        // è™•ç†æ˜Ÿæ˜Ÿ
        starTimer += deltaTime;
        if (starTimer > 1000) { // æ¯ç§’å˜—è©¦ç”Ÿæˆæ˜Ÿæ˜Ÿ
            spawnStar();
            starTimer = 0;
        }

        for (let i = stars.length - 1; i >= 0; i--) {
            const s = stars[i];
            
            // æ˜Ÿæ˜Ÿè„ˆå‹•æ•ˆæœ
            const pulse = Math.sin(timestamp / 200) * 3;
            
            // ç¹ªè£½æ˜Ÿæ˜Ÿ (é‡‘è‰²åœ“å½¢å¸¶å…‰æšˆ)
            gameCtx.beginPath();
            gameCtx.arc(s.x, s.y, s.radius + pulse, 0, 2 * Math.PI);
            gameCtx.fillStyle = '#ffd700';
            gameCtx.shadowBlur = 15;
            gameCtx.shadowColor = '#ffd700';
            gameCtx.fill();
            gameCtx.shadowBlur = 0;
            gameCtx.strokeStyle = '#fff';
            gameCtx.lineWidth = 2;
            gameCtx.stroke();
            gameCtx.closePath();
            
            // æ˜Ÿæ˜Ÿå…§éƒ¨å…‰é»
            gameCtx.beginPath();
            gameCtx.arc(s.x, s.y, s.radius / 2, 0, 2 * Math.PI);
            gameCtx.fillStyle = '#fff';
            gameCtx.fill();
            gameCtx.closePath();

            // ç¢°æ’æª¢æ¸¬ (ç©å®¶ vs æ˜Ÿæ˜Ÿ)
            const dist = Math.hypot(player.x - s.x, player.y - s.y);
            if (dist < player.radius + s.radius) {
                // æ”¶é›†æˆåŠŸ
                score += 10;
                scoreDisplay.innerText = score; // å³æ™‚æ›´æ–°åˆ†æ•¸é¡¯ç¤º
                createParticles(s.x, s.y, '#ffd700', 15);
                createParticles(s.x, s.y, '#ffffff', 10);
                
                // æ’­æ”¾æ”¶é›†éŸ³æ•ˆ
                gameAudio.playCollect();
                
                stars.splice(i, 1);
                
                // é›£åº¦éš¨åˆ†æ•¸æå‡
                if (score % 50 === 0) {
                    obstacleSpeedMultiplier += 0.1;
                }
                
                // æ¯æ¬¡æ”¶é›†æ˜Ÿæ˜Ÿéƒ½æ›´æ–°åˆ†æ•¸é¡¯ç¤º
                updateScoreDisplay();
            }
        }

        // è™•ç†éšœç¤™ç‰©
        obstacleTimer += deltaTime;
        // ç”Ÿæˆé »ç‡éš¨é›£åº¦ç•¥å¾®åŠ å¿«ï¼Œä½†æœ‰ä¸Šé™
        let spawnRate = Math.max(500, 1000 - (score * 2)); 
        if (obstacleTimer > spawnRate) {
            spawnObstacle();
            obstacleTimer = 0;
        }

        for (let i = obstacles.length - 1; i >= 0; i--) {
            const obs = obstacles[i];
            obs.y += obs.speed * obstacleSpeedMultiplier;
            obs.rotation += 0.05;

            // ç¹ªè£½éšœç¤™ç‰© (ç´…è‰²å¸¶åˆºçƒé«”æ„Ÿ)
            gameCtx.save();
            gameCtx.translate(obs.x, obs.y);
            gameCtx.rotate(obs.rotation);
            gameCtx.beginPath();
            // ç•«ä¸€å€‹ç°¡å–®çš„å¤šé‚Šå½¢æ¨¡æ“¬åˆº
            const spikes = 8;
            const outerRadius = obs.radius;
            const innerRadius = obs.radius / 2;
            for(let j=0; j<spikes*2; j++){
                const r = (j%2 === 0) ? outerRadius : innerRadius;
                const currAngle = (Math.PI / spikes) * j;
                const x = Math.cos(currAngle) * r;
                const y = Math.sin(currAngle) * r;
                if(j===0) gameCtx.moveTo(x, y);
                else gameCtx.lineTo(x, y);
            }
            gameCtx.closePath();
            gameCtx.fillStyle = '#ff4757';
            gameCtx.shadowBlur = 10;
            gameCtx.shadowColor = '#ff4757';
            gameCtx.fill();
            gameCtx.shadowBlur = 0;
            gameCtx.restore();

            // ç§»é™¤è¶…å‡ºç•«é¢çš„éšœç¤™ç‰©
            if (obs.y > gameCanvas.height + obs.radius) {
                obstacles.splice(i, 1);
                continue;
            }

            // ç¢°æ’æª¢æ¸¬ (ç©å®¶ vs éšœç¤™ç‰©)
            // ç‚ºäº†å…¬å¹³ä¸€é»ï¼Œéšœç¤™ç‰©ç¢°æ’åˆ¤å®šç¨å¾®æ¯”è¦–è¦ºå°ä¸€é»
            const dist = Math.hypot(player.x - obs.x, player.y - obs.y);
            if (dist < (player.radius + obs.radius * 0.8)) {
                // ç¢°æ’æ™‚ç”¢ç”Ÿçˆ†ç‚¸ç²’å­æ•ˆæœ
                createParticles(obs.x, obs.y, '#ff4757', 30);
                createParticles(player.x, player.y, '#00d2ff', 20);
                
                // æ’­æ”¾ç¢°æ’éŸ³æ•ˆ
                gameAudio.playCollision();
                
                gameOver();
                return;
            }
        }

        // ç²’å­æ•ˆæœæ›´æ–°
        updateAndDrawParticles();

        // æŒçºŒç”¢ç”Ÿç©å®¶ç§»å‹•å¾®ç²’
        if (isGameRunning && handDetected && Math.random() < 0.4) {
            createParticles(player.x, player.y, '#00d2ff', 1);
        }

        requestAnimationFrame(gameLoop);
    }

    // å³æ™‚æ›´æ–°åˆ†æ•¸é¡¯ç¤º
    function updateScoreDisplay() {
        scoreDisplay.innerText = score;
        scoreDisplay.style.transform = 'scale(1.2)';
        setTimeout(() => {
            scoreDisplay.style.transform = 'scale(1)';
        }, 200);
    }

    // --- ç”Ÿæˆå™¨ ---

    function spawnStar() {
        if (stars.length > 3) return; // é™åˆ¶åŒæ™‚å­˜åœ¨çš„æ•¸é‡
        stars.push({
            x: Math.random() * (gameCanvas.width - 40) + 20,
            y: Math.random() * (gameCanvas.height - 40) + 20,
            radius: 15
        });
    }

    function spawnObstacle() {
        const radius = Math.random() * 15 + 15; // 15~30
        obstacles.push({
            x: Math.random() * gameCanvas.width,
            y: -radius,
            radius: radius,
            speed: Math.random() * 3 + 2, // åŸºç¤é€Ÿåº¦
            rotation: 0
        });
    }

    // --- ç²’å­ç³»çµ± (è¦–è¦ºæ•ˆæœ) ---
    function createParticles(x, y, color, count = 8) {
        // æ ¹æ“šæ€§èƒ½èª¿æ•´ç²’å­æ•¸é‡
        const maxParticles = performanceOptimizer.getOptimalParticleCount();
        const adjustedCount = Math.min(count, Math.floor(maxParticles / 10));
        
        // æª¢æŸ¥ç²’å­ç¸½æ•¸æ˜¯å¦è¶…éé™åˆ¶
        if (particles.length >= maxParticles) {
            // ç§»é™¤æœ€èˆŠçš„ç²’å­
            particles.splice(0, Math.min(particles.length - maxParticles + adjustedCount, adjustedCount));
        }
        
        for (let i = 0; i < adjustedCount; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 1.0,
                color: color,
                size: Math.random() * 4 + 2
            });
        }
    }

    function updateAndDrawParticles() {
        // æ€§èƒ½å„ªåŒ–ï¼šä½è³ªé‡æ™‚å¯èƒ½è·³å¹€
        if (performanceOptimizer.shouldSkipFrame() && Math.random() < 0.5) {
            return;
        }
        
        particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
        
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            
            if (p.life <= 0) {
                particles.splice(i, 1);
            } else {
                particlesCtx.globalAlpha = p.life;
                particlesCtx.fillStyle = p.color;
                particlesCtx.beginPath();
                particlesCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                particlesCtx.fill();
                particlesCtx.globalAlpha = 1.0;
            }
        }
    }

    // --- éŠæˆ²æµç¨‹æ§åˆ¶ ---

    function startGame() {
        // æ’­æ”¾éŠæˆ²é–‹å§‹éŸ³æ•ˆä¸¦åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
        if (!gameAudio.initialized) {
            gameAudio.init();
        }
        gameAudio.playStartGame();
        gameAudio.playBackgroundAmbient();
        
        // å•Ÿç”¨å‚™ç”¨æ§åˆ¶ç³»çµ±
        fallbackControls.enable();
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        hud.classList.remove('hidden');
        
        isGameRunning = true;
        score = 0;
        obstacleSpeedMultiplier = 1;
        scoreDisplay.innerText = score;
        
        stars = [];
        obstacles = [];
        particles = [];
        player.trail = [];

        // åˆå§‹ç”Ÿæˆä¸€å€‹æ˜Ÿæ˜Ÿ
        spawnStar();

        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        isGameRunning = false;
        finalScoreDisplay.innerText = score;
        
        // åœæ­¢èƒŒæ™¯éŸ³æ¨‚ä¸¦æ’­æ”¾éŠæˆ²çµæŸéŸ³æ•ˆ
        gameAudio.stopBackgroundAmbient();
        gameAudio.playGameOver();
        
        // ç¦ç”¨å‚™ç”¨æ§åˆ¶ç³»çµ±
        fallbackControls.disable();
        
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('handGameHighScore', highScore);
            highScoreDisplay.innerText = highScore;
        }

        gameOverScreen.classList.remove('hidden');
        hud.classList.add('hidden');
    }

    // æˆå°±ç³»çµ±
    class AchievementSystem {
        constructor() {
            this.achievements = this.loadAchievements();
            this.notification = null;
            this.init();
        }
        
        loadAchievements() {
            const saved = localStorage.getItem('gestureGameAchievements');
            if (saved) return JSON.parse(saved);
            
            return [
                {
                    id: 'first_star',
                    title: 'åˆå­¦è€…',
                    description: 'æ”¶é›†ç¬¬ä¸€é¡†æ˜Ÿæ˜Ÿ',
                    icon: 'â­',
                    unlocked: false,
                    condition: () => score >= 10
                },
                {
                    id: 'score_100',
                    title: 'ç™¾åˆ†é”äºº',
                    description: 'å¾—åˆ†è¶…é100',
                    icon: 'ğŸ’¯',
                    unlocked: false,
                    condition: () => score >= 100
                },
                {
                    id: 'score_500',
                    title: 'é«˜åˆ†ç©å®¶',
                    description: 'å¾—åˆ†è¶…é500',
                    icon: 'ğŸŒŸ',
                    unlocked: false,
                    condition: () => score >= 500
                },
                {
                    id: 'score_1000',
                    title: 'åƒåˆ†é”äºº',
                    description: 'å¾—åˆ†è¶…é1000',
                    icon: 'ğŸ‘‘',
                    unlocked: false,
                    condition: () => score >= 1000
                },
                {
                    id: 'survivor_30s',
                    title: 'ç”Ÿå­˜å°ˆå®¶',
                    description: 'ç”Ÿå­˜30ç§’',
                    icon: 'â°',
                    unlocked: false,
                    condition: () => false // éœ€è¦æ™‚é–“è¿½è¹¤
                },
                {
                    id: 'survivor_60s',
                    title: 'ç”Ÿå­˜å¤§å¸«',
                    description: 'ç”Ÿå­˜60ç§’',
                    icon: 'â±ï¸',
                    unlocked: false,
                    condition: () => false // éœ€è¦æ™‚é–“è¿½è¹¤
                },
                {
                    id: 'collector',
                    title: 'æ”¶é›†è€…',
                    description: 'é€£çºŒæ”¶é›†10é¡†æ˜Ÿæ˜Ÿ',
                    icon: 'ğŸ’',
                    unlocked: false,
                    condition: () => false // éœ€è¦é€£çºŒè¿½è¹¤
                },
                {
                    id: 'dodge_master',
                    title: 'é–ƒé¿å¤§å¸«',
                    description: 'èº²é¿50å€‹éšœç¤™ç‰©',
                    icon: 'ğŸ›¡ï¸',
                    unlocked: false,
                    condition: () => false // éœ€è¦éšœç¤™ç‰©è¿½è¹¤
                }
            ];
        }
        
        init() {
            this.createNotification();
            this.startTime = 0;
            this.consecutiveStars = 0;
            this.dodgedObstacles = 0;
            this.lastStarTime = 0;
        }
        
        createNotification() {
            this.notification = document.createElement('div');
            this.notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: -400px;
                background: linear-gradient(135deg, #1a1a2e, #16213e);
                border: 2px solid gold;
                border-radius: 15px;
                padding: 20px;
                min-width: 300px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                z-index: 3000;
                transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            `;
            
            this.notification.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <div style="font-size: 2rem; margin-right: 15px;">ğŸ†</div>
                    <div style="color: gold; font-size: 1.2rem; font-weight: bold;">æˆå°±è§£é–ï¼</div>
                </div>
                <div style="color: #f0f0f0; font-size: 0.9rem; margin-bottom: 5px;" id="achievement-desc">æè¿°</div>
            `;
            
            document.body.appendChild(this.notification);
        }
        
        startGame() {
            this.startTime = Date.now();
            this.consecutiveStars = 0;
            this.dodgedObstacles = 0;
            this.lastStarTime = 0;
        }
        
        onStarCollected() {
            this.consecutiveStars++;
            const now = Date.now();
            
            // æª¢æŸ¥é€£çºŒæ”¶é›†æˆå°±
            if (this.consecutiveStars >= 10) {
                const achievement = this.achievements.find(a => a.id === 'collector');
                if (achievement && !achievement.unlocked) {
                    achievement.unlocked = true;
                    this.showUnlockNotification(achievement);
                }
            }
            
            this.lastStarTime = now;
        }
        
        onObstacleDodged() {
            this.dodgedObstacles++;
            
            // æª¢æŸ¥é–ƒé¿æˆå°±
            if (this.dodgedObstacles >= 50) {
                const achievement = this.achievements.find(a => a.id === 'dodge_master');
                if (achievement && !achievement.unlocked) {
                    achievement.unlocked = true;
                    this.showUnlockNotification(achievement);
                }
            }
        }
        
        onMissedStar() {
            this.consecutiveStars = 0;
        }
        
        checkAchievements() {
            // æª¢æŸ¥æ™‚é–“æˆå°±
            if (this.startTime > 0) {
                const survivalTime = (Date.now() - this.startTime) / 1000;
                
                if (survivalTime >= 30) {
                    const achievement = this.achievements.find(a => a.id === 'survivor_30s');
                    if (achievement && !achievement.unlocked) {
                        achievement.unlocked = true;
                        this.showUnlockNotification(achievement);
                    }
                }
                
                if (survivalTime >= 60) {
                    const achievement = this.achievements.find(a => a.id === 'survivor_60s');
                    if (achievement && !achievement.unlocked) {
                        achievement.unlocked = true;
                        this.showUnlockNotification(achievement);
                    }
                }
            }
            
            // æª¢æŸ¥åˆ†æ•¸æˆå°±
            let newUnlocks = [];
            this.achievements.forEach(achievement => {
                if (!achievement.unlocked && achievement.condition()) {
                    achievement.unlocked = true;
                    newUnlocks.push(achievement);
                }
            });
            
            if (newUnlocks.length > 0) {
                this.saveAchievements();
                newUnlocks.forEach(achievement => {
                    this.showUnlockNotification(achievement);
                });
            }
        }
        
        showUnlockNotification(achievement) {
            const descElement = document.getElementById('achievement-desc');
            descElement.textContent = achievement.title + ' - ' + achievement.description;
            
            this.notification.classList.add('show');
            this.notification.style.right = '20px';
            
            // æ’­æ”¾æˆå°±éŸ³æ•ˆ
            gameAudio.playAchievement();
            
            // å‰µå»ºæ…¶ç¥ç²’å­æ•ˆæœ
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    createParticle(
                        Math.random() * canvas.width,
                        Math.random() * canvas.height,
                        '#FFD700',
                        Math.random() * 10 + 5
                    );
                }, i * 50);
            }
            
            setTimeout(() => {
                this.notification.style.right = '-400px';
            }, 4000);
        }
        
        saveAchievements() {
            localStorage.setItem('gestureGameAchievements', JSON.stringify(this.achievements));
        }
    }
    
    // åˆå§‹åŒ–æˆå°±ç³»çµ±
    const achievementSystem = new AchievementSystem();
    
    // ä¿®æ”¹éŠæˆ²é‚è¼¯ä»¥é›†æˆæˆå°±ç³»çµ±
    const originalSpawnStar = spawnStar;
    spawnStar = function() {
        originalSpawnStar();
    };
    
    const originalCollectStar = collectStar;
    collectStar = function(star) {
        const collected = originalCollectStar(star);
        if (collected) {
            achievementSystem.onStarCollected();
        }
        return collected;
    };
    
    const originalStartGame = startGame;
    startGame = function() {
        achievementSystem.startGame();
        originalStartGame();
    };
    
    // åœ¨éŠæˆ²å¾ªç’°ä¸­æª¢æŸ¥æˆå°±
    const originalGameLoop = gameLoop;
    gameLoop = function(currentTime) {
        const result = originalGameLoop(currentTime);
        
        // æ¯ç§’æª¢æŸ¥ä¸€æ¬¡æˆå°±
        if (Math.floor(currentTime / 1000) !== Math.floor(lastTime / 1000)) {
            achievementSystem.checkAchievements();
        }
        
        return result;
    };
    
    // ç‚ºgameAudioæ·»åŠ æˆå°±éŸ³æ•ˆ
    if (gameAudio && typeof gameAudio === 'object') {
        gameAudio.playAchievement = function() {
            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
            frequencies.forEach((freq, index) => {
                setTimeout(() => {
                    this.playSound(freq, 0.3, 'sine', 0.4);
                }, index * 100);
            });
            
            if ('vibrate' in navigator) {
                navigator.vibrate([50, 30, 50, 30, 100]);
            }
        };
    }

    // æ€§èƒ½ç›£æ§ç³»çµ±
    class PerformanceMonitor {
        constructor() {
            this.fps = 0;
            this.frameCount = 0;
            this.lastTime = performance.now();
            this.monitor = document.getElementById('performance-monitor');
            this.fpsDisplay = document.getElementById('fps-display');
            this.particleCountDisplay = document.getElementById('particle-count');
            this.handStatusDisplay = document.getElementById('hand-status');
            this.controlModeDisplay = document.getElementById('control-mode');
            this.isVisible = false;
            this.init();
        }
        
        init() {
            // é–‹ç™¼è€…å¿«æ·éµ
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F12' || (e.key === 'p' && e.ctrlKey)) {
                    e.preventDefault();
                    this.toggle();
                }
            });
            
            this.update();
        }
        
        toggle() {
            this.isVisible = !this.isVisible;
            if (this.isVisible) {
                this.monitor.classList.add('active');
            } else {
                this.monitor.classList.remove('active');
            }
        }
        
        update() {
            if (!this.isVisible) return;
            
            // è¨ˆç®—FPS
            this.frameCount++;
            const currentTime = performance.now();
            const deltaTime = currentTime - this.lastTime;
            
            if (deltaTime >= 1000) {
                this.fps = Math.round((this.frameCount * 1000) / deltaTime);
                this.frameCount = 0;
                this.lastTime = currentTime;
                
                // æ›´æ–°é¡¯ç¤º
                this.fpsDisplay.textContent = this.fps;
                this.fpsDisplay.style.color = this.fps < 30 ? '#ff0000' : 
                                            this.fps < 50 ? '#ffaa00' : '#00ff00';
            }
            
            // æ›´æ–°ç²’å­æ•¸é‡
            this.particleCountDisplay.textContent = particles.length;
            
            // æ›´æ–°æ‰‹éƒ¨ç‹€æ…‹
            this.handStatusDisplay.textContent = hands ? 'å·²æª¢æ¸¬' : 'æœªæª¢æ¸¬';
            
            // æ›´æ–°æ§åˆ¶æ¨¡å¼
            this.controlModeDisplay.textContent = fallbackControls.isEnabled ? 'éµç›¤' : 'æ‰‹å‹¢';
            
            requestAnimationFrame(() => this.update());
        }
        
        show() {
            if (!this.isVisible) {
                this.toggle();
            }
        }
        
        hide() {
            if (this.isVisible) {
                this.toggle();
            }
        }
    }
    
    // åˆå§‹åŒ–æ€§èƒ½ç›£æ§
    const performanceMonitor = new PerformanceMonitor();

    // å®‰å…¨åˆå§‹åŒ–å‡½æ•¸
        function safeInit() {
            try {
                console.log('é–‹å§‹åˆå§‹åŒ–æ˜Ÿæ˜Ÿé–ƒé¿...');
                
                // æª¢æŸ¥é—œéµDOMå…ƒç´ 
                const gameCanvas = document.getElementById('game-canvas');
                const particlesCanvas = document.getElementById('particles-canvas');
                const videoElement = document.getElementById('input-video');
                
                if (!gameCanvas || !particlesCanvas) {
                    console.error('æ‰¾ä¸åˆ°å¿…è¦çš„ç•«å¸ƒå…ƒç´ ');
                    showError('éŠæˆ²åˆå§‹åŒ–å¤±æ•—ï¼šæ‰¾ä¸åˆ°ç•«å¸ƒå…ƒç´ ');
                    return;
                }
                
                // æª¢æŸ¥Canvasä¸Šä¸‹æ–‡
                const gameCtx = gameCanvas.getContext('2d');
                const particlesCtx = particlesCanvas.getContext('2d');
                
                if (!gameCtx || !particlesCtx) {
                    console.error('ç„¡æ³•å‰µå»ºCanvas 2Dä¸Šä¸‹æ–‡');
                    showError('éŠæˆ²åˆå§‹åŒ–å¤±æ•—ï¼šç€è¦½å™¨ä¸æ”¯æŒCanvas');
                    return;
                }
                
// åˆå§‹åŒ–æ€§èƒ½ç›£æ§
        const performanceMonitor = new PerformanceMonitor();
        
        // è¨­ç½®ç•«å¸ƒå°ºå¯¸
        function setupCanvases() {
            const container = document.getElementById('game-container');
            gameCanvas.width = 800;
            gameCanvas.height = 600;
            particlesCanvas.width = 800;
            particlesCanvas.height = 600;
        }
        
        // åˆå§‹åŒ–æ”å½±æ©Ÿç³»çµ±
        function initCameraSystem() {
            try {
                console.log('åˆå§‹åŒ–æ”å½±æ©Ÿç³»çµ±...');
                
                // æª¢æŸ¥MediaPipeæ˜¯å¦å¯ç”¨
                if (typeof Hands === 'undefined') {
                    console.warn('MediaPipe Handsæœªè¼‰å…¥ï¼Œä½¿ç”¨å‚™ç”¨æ§åˆ¶æ¨¡å¼');
                    fallbackControls.setMode('touch');
                    return;
                }
                
                // åˆå§‹åŒ–MediaPipe Hands
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onHandsResults);
                
                // åˆå§‹åŒ–æ”å½±æ©Ÿ
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 1280,
                    height: 720
                });
                
                // å•Ÿå‹•æ”å½±æ©Ÿ
                camera.start()
                    .then(() => {
                        console.log("æ”å½±æ©Ÿå·²å•Ÿå‹•");
                        statusDot.className = 'dot ready';
                        statusText.innerText = "ç³»çµ±æº–å‚™å°±ç·’";
                        startBtn.disabled = false;
                        startBtn.innerText = "é–‹å§‹éŠæˆ²";
                    })
                    .catch(err => {
                        console.error("æ”å½±æ©ŸéŒ¯èª¤:", err);
                        statusDot.className = 'dot error';
                        statusText.innerText = "ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿï¼Œä½¿ç”¨å‚™ç”¨æ§åˆ¶";
                        
                        // è‡ªå‹•åˆ‡æ›åˆ°å‚™ç”¨æ§åˆ¶æ¨¡å¼
                        fallbackControls.setMode('touch');
                        startBtn.disabled = false;
                        startBtn.innerText = "é–‹å§‹éŠæˆ²";
                    });
                
                console.log('æ”å½±æ©Ÿç³»çµ±åˆå§‹åŒ–å®Œæˆ');
                
            } catch (error) {
                console.error('æ”å½±æ©Ÿç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
                // åˆ‡æ›åˆ°å‚™ç”¨æ§åˆ¶æ¨¡å¼
                fallbackControls.setMode('touch');
                startBtn.disabled = false;
                startBtn.innerText = "é–‹å§‹éŠæˆ²";
            }
        }
        
        setupCanvases();
        initCameraSystem();
                
                // é¡¯ç¤ºéŠæˆ²ç•Œé¢
                document.getElementById('start-screen').classList.remove('hidden');
                
                console.log('æ˜Ÿæ˜Ÿé–ƒé¿åˆå§‹åŒ–å®Œæˆ');
                
            } catch (error) {
                console.error('æ˜Ÿæ˜Ÿé–ƒé¿åˆå§‹åŒ–å¤±æ•—:', error);
                showError('éŠæˆ²åˆå§‹åŒ–å¤±æ•—: ' + error.message);
            }
        }
        
        // éŒ¯èª¤é¡¯ç¤ºå‡½æ•¸
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #ff4757;
                color: white;
                padding: 20px;
                border-radius: 10px;
                font-family: Arial, sans-serif;
                z-index: 9999;
                text-align: center;
            `;
            errorDiv.innerHTML = `
                <h3>âš ï¸ éŒ¯èª¤</h3>
                <p>${message}</p>
                <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 15px; background: white; color: #ff4757; border: none; border-radius: 5px; cursor: pointer;">é‡æ–°è¼‰å…¥</button>
            `;
            document.body.appendChild(errorDiv);
        }
        
        // ç­‰å¾…DOMåŠ è¼‰å®Œæˆå¾Œåˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', safeInit);
        } else {
            safeInit();
        }
        
        // --- äº‹ä»¶ç›£è½ ---
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);

    }); // DOMContentLoaded çµæŸ
</script>

<!-- æˆå°±é€šçŸ¥ -->
<div id="achievement-notification" style="display: none;">
    <h3>ğŸ† æˆå°±è§£é–ï¼</h3>
    <p id="achievement-description">æè¿°</p>
</div>

<!-- æ€§èƒ½ç›£æ§é¢æ¿ -->
<div class="performance-monitor" id="performance-monitor">
    <div>FPS: <span id="fps-display">0</span></div>
    <div>ç²’å­æ•¸: <span id="particle-count">0</span></div>
    <div>æ‰‹éƒ¨æª¢æ¸¬: <span id="hand-status">æœªå•Ÿç”¨</span></div>
    <div>æ§åˆ¶æ¨¡å¼: <span id="control-mode">æ‰‹å‹¢</span></div>
</div>

</body>
</html>